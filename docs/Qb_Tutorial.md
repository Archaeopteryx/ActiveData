ActiveData: Qb Query Tutorial (incomplete)
==========================================

Qb queries are JSON structures that attempt to mimic SQL queries, where property names correspond to SQL clauses.  There are some differences from SQL, especially when it comes to using default clauses, but I hope your knowledge of SQL can jump-start your use of Qb.


Simple `from` Clause 
--------------------

All queries must have a `from` clause, which indicates what data is being queried.  ActiveData has a default container, which it uses to translate names to explicit data cubes to query.

```javascript
	{"from": "unittest"}

```

In this case, we will get some records from the `unittest` cube.  Please note: ActiveData assigns a default limit on all requests to prevent returning overwhelmingly large results by accident.


`format` Clause
---------------

The ActiveData Query Tool hides the formatting feature of the ActiveData service.  Most responses you get back from the service are data cubes (aka pivot tables), and this may not be the best format for your application.  You have three main formats to choose from:

* `list` - service will return a list of JSON objects, which is great if you want to see the original source documents. 
* `table` - service returns a table - There is a header containing the names of the columns, and the data which is a list of tuples containing row values.  This form is generally more compact than the other two forms.
* `cube` - (default) returns the cube form - This format is good for analysis, charting, and is compact for large, dense, datasets.

```javascript
	{
		"from":"unittest",
		"format":"list"
	}
```

`limit` Clause
--------------

The ActiveData service limits responses to 10 rows by default.  To increase this limit (or decrease it) Use the `limit` clause to set an upper bound on the response:

```javascript
	{
		"from": "unittest",
		"limit": 100
	}

```

`where` Clause
--------------

Use the `where` clause to restrict our results to those that match

```javascript
{
	"from": "unittest",
	"where":{"eq":{"machine.platform": "linux64"}}
}
```

in this case, we limit ourselves to test results on `linux64` platform.

`select` Clause
---------------

The `unittest` records are quite large, and in most cases you will not be interested in all the properties.  Let's look at how big some test result files can be; list all files over 600 megabytes!  

```javascript
{
	"from":"unittest",
	"select":"run.stats.bytes",
	"where":{"and":[
		{"eq":{"machine.platform":"linux64"}},
		{"gt":{"run.stats.bytes":600000000}}
	]}
}
```

Knowing the size is not enough: What files are they?

```javascript
{
	"from":"unittest",
	"select":[
		"run.stats.bytes",
		"run.files.url"
	],
	"where":{"and":[
		{"eq":{"machine.platform":"linux64"}},
		{"gt":{"run.stats.bytes":600000000}}
	]}
}
```

It appears there are multiple files generated by each test run, at least one of them is the culprit.   Also notice the `select` clause can be an array of properties.

Grouping
----------

Pulling individual records is unexciting, and it will take forever to get an understanding of the billion+ records behind it.  ActiveData's objective is to provide aggregates fast.

`groupby` Clause
----------------

How many of these monster files are there?

```javascript
{
	"from":"unittest",
	"groupby":["machine.platform"],
	"where":{"and":[
		{"eq":{"etl.id":0}},
		{"gt":{"run.stats.bytes":600000000}}		
	]}
}
```

A few notes on this query: First, if there is no `select` clause when using the  `groupby` clause, it is assumed a `count` is requested.  Second, the properties in the `groupby` clause will be included in the result set.  Finally, and most important:

> The `unittest` data cube is a list of **test results** not test runs; each run has multiple results, so if we want to accurately count the number of runs we must pick a specific test result that will act as representative: Your best choice is `etl.id==0`.

How big do these files get?

```javascript
{
	"from":"unittest",
	"select":{"value":"run.stats.bytes","aggregate":"max"},
	"groupby":["machine.platform"],
	"where":{"and":[
		{"eq":{"etl.id":0}},
		{"gt":{"run.stats.bytes":600000000}}
	]}
}
```

At time of this writing we see structured logs of over 1.1 Gigabytes!  No wonder my Python processes were running out of memory! 


`edges` Clause
--------------

The `edges` clause works just like `groupby` except its domain is unaffected by the filter:

```javascript
{
	"from":"unittest",
	"select":{"value":"run.stats.bytes","aggregate":"max"},
	"edges":["machine.platform"],
	"where":{"and":[
		{"eq":{"etl.id":0}},
		{"gt":{"run.stats.bytes":600000000}}
	]}
}
```



**THIS TUTORIAL IS INCOMPLETE**

 

